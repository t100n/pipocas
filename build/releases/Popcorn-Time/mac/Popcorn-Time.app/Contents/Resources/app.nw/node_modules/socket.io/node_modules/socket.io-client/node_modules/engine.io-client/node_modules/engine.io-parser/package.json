{
  "name": "engine.io-parser",
  "description": "Parser for the client for the realtime Engine",
  "version": "1.0.0",
  "homepage": "https://github.com/LearnBoost/engine.io-protocol",
  "dependencies": {
    "base64-arraybuffer": "0.1.0",
    "after": "0.8.1",
    "arraybuffer.slice": "0.0.5"
  },
  "devDependencies": {
    "mocha": "*",
    "expect.js": "*"
  },
  "component": {
    "scripts": {
      "engine.io-parser/index.js": "lib/index.js",
      "engine.io-parser/keys.js": "lib/keys.js"
    }
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:LearnBoost/engine.io-protocol.git"
  },
  "browser": "./lib/browser.js",
  "readme": "\n# Engine.IO Protocol\n\n## Revision\n\nThis is revision **3** of the Engine.IO protocol.\n\n## Anatomy of an Engine.IO session\n\n1. Transport establishes a connection to the Engine.IO URL .\n2. Server responds with an `open` packet with JSON-encoded handshake data:\n  - `sid` session id (`String`)\n  - `upgrades` possible transport upgrades (`Array` of `String`)\n  - `pingTimeout` server configured ping timeout, used for the client\n    to detect that the server is unresponsive (`Number`)\n3. Client must respond to periodic `ping` packets sent by the server\nwith `pong` packets.\n4. Client and server can exchange `message` packets at will.\n5. Polling transports can send a `close` packet to close the socket, since\nthey're expected to be \"opening\" and \"closing\" all the time.\n\n## URLs\n\nAn Engine.IO url is composed as follows:\n\n`/engine.io/` [ ? <query string> ]\n\n- The `engine.io` pathname should only be changed by higher-level\n  frameworks whose protocol sits on top of engine's.\n\n- The query string is optional and has four reserved keys:\n\n  - `transport`: indicates the transport name. Supported ones by default are\n    `polling`, `flashsocket`, `websocket`.\n  - `j`: if the transport is `polling` but a JSONP response is required, `j`\n    must be set with the JSONP response index.\n  - `sid`: if the client has been given a session id, it must be included\n    in the querystring.\n  - `b64`: if the client doesn't support XHR2, `b64=1` is sent in the query string\n    to signal the server that all binary data should be sent base64 encoded.\n\n*FAQ:* Is the `/engine.io` portion modifiable?\n\nProvided the server is customized to intercept requests under a different\npath segment, yes.\n\n*FAQ:* What determines whether an option is going to be part of the path\nversus being encoded as part of the query string? In other words, why\nis the `transport` not part of the URL?\n\nIt's convention that the path segments remain *only* that which allows to\ndisambiguate whether a request should be handled by a given Engine.IO\nserver instance or not. As it stands, it's only the Engine.IO prefix\n(`/engine.io`) and the resource (`default` by default).\n\n## Encoding\n\nThere's two distinct types of encodings\n\n- packet\n- payload\n\n### Packet\n\nAn encoded packet can be UTF-8 string or binary data. The packet encoding format for a string is as follows\n\n```\n<packet type id>[<data>]\n```\nexample:\n```\n2probe\n```\nFor binary data the encoding is identical. When sending binary data, the packet\ntype id is sent in the first byte of the binary contents, followed by the\nactual packet data. Example:\n\n```\n4|0|1|2|3|4|5\n```\n\nIn the above example each byte is separated by a pipe character and shown as an\ninteger. So the above packet is of type message (see below), and contains\nbinary data that corresponds to an array of integers with values 0, 1, 2, 3, 4\nand 5.\n\nThe packet type id is an integer. The following are the accepted packet\ntypes.\n\n#### 0 open\n\nSent from the server when a new transport is opened (recheck)\n\n#### 1 close\n\nRequest the close of this transport but does not shutdown the connection itself.\n\n#### 2 ping\n\nsend by the server. Client should answer with a pong packets, containing the same data\n\nexample\n1. server sends: ```2probe```\n2. client sends: ```3probe```\n\n#### 3 pong\n\nsend by the client to respond to ping packets.\n\n#### 4 message\n\nactual message, client and server should call their callbacks with the data.\n\n##### example 1\n\n1. server sends: ```4HelloWorld```\n2. client receives and calls callback ```socket.on('message', function (data) { console.log(data); });```\n\n##### example 2\n\n1. client sends: ```4HelloWorld```\n2. server receives and calls callback ```socket.on('message', function (data) { console.log(data); });```\n\n#### 5 upgrade\n\nBefore engine.io switches a transport, it tests, if server and client can communicate over this transport.\nIf this test succeed, the client sends an upgrade packets which requests the server to flush its cache on\nthe old transport and switch to the new transport.\n\n#### 6 noop\n\nA noop packet. Used primarily to force a poll cycle when an incoming websocket connection is received.\n\n##### example\n1. client connects through new transport\n2. client sends ```2probe```\n3. server receives and sends ```3probe```\n4. client receives and sends ```5```\n5. server flushes and closes old transport and switches to new.\n\n### Payload\n\nA payload is a series of encoded packets tied together. The payload encoding format is as follows when only strings are sent and XHR2 is not supported:\n\n```\n<length1>:<packet1>[<length2>:<packet2>[...]]\n```\n* length: length of the packet in __characters__\n* packet: actual packets as descriped above\n\nWhen XHR2 is not supported, the same encoding principle is used also when\nbinary data is sent, but it is sent as base64 encoded strings. For the purposes of decoding, an identifier `b` is\nput before a packet encoding that contains binary data. A combination of any\nnumber of strings and base64 encoded strings can be sent. Here is an example of\nbase 64 encoded messages:\n\n```\n<length of base64 representation of the data + 1 (for packet type)>:b<packet1 type><packet1 data in b64>[...]\n```\n\nWhen XHR2 is supported, a similar principle is used, but everything is encoded\ndirectly into binary, so that it can be sent as binary over XHR. The format is\nthe following:\n\n<0 for string data, 1 for binary data><Any number of numbers between 0 and 9><The number 255><packet1 (first type,\nthen data)>[...]\n\nIf a combination of UTF-8 strings and binary data is sent, the string values\nare represented so that each character is written as a character code into a\nbyte.\n\nThe payload is used for transports which do not support framing, as the polling protocol for example.\n\n## Transports\n\nAn engine.io server must support three transports:\n\n- websocket\n- flashsocket\n- polling\n  - jsonp\n  - xhr\n\n### Polling\n\nThe polling transport consists of recurring GET requests by the client\nto the server to get data, and POST requests with payloads from the\nclient to the server to send data.\n\n#### XHR\n\nThe server must support CORS responses.\n\n#### JSONP\n\nThe server implementation must respond with valid JavaScript. The URL\ncontains a query string parameter `j` that must be used in the response.\n`j` is an integer.\n\nThe format of a JSONP packet.\n\n```\n`___eio[` <j> `](\"` <encoded payload> `\");`\n```\n\nTo ensure that the payload gets processed correctly, it must be escaped\nin such a way that the response is still valid JavaScript. Passing the\nencoded payload through a JSON encoder is a good way to escape it.\n\nExample JSONP frame returned by the server:\n\n```\n___eio[4](\"packet data\");\n```\n\n##### Posting data\n\nThe client posts data through a hidden iframe. The data gets to the server\nin the URI encoded format as follows:\n\n```\nd=<escaped packet payload>\n```\n\nIn addition to the regular qs escaping, in order to prevent\ninconsistencies with `\\n` handling by browsers, `\\n` gets escaped as `\\\\n`\nprior to being POSTd.\n\n### WebSocket\n\nEncoding payloads _should not_ be used for WebSocket, as the protocol\nalready has a lightweight framing mechanism.\n\nIn order to send a payload of messages, encode packets individually\nand `send()` them in succession.\n\n## Transport upgrading\n\nA connection always starts with polling (either XHR or JSONP). WebSocket\ngets tested on the side by sending a probe. If the probe is responded\nfrom the server, an upgrade packet is sent.\n\nTo ensure no messages are lost, the upgrade packet will only be sent\nonce all the buffers of the existing transport are flushed and the\ntransport is considered _paused_.\n\nWhen the server receives the upgrade packet, it must assume this is the\nnew transport channel and send all existing buffers (if any) to it.\n\nThe probe sent by the client is a `ping` packet with `probe` sent as data.\nThe probe sent by the server is a `pong` packet with `probe` sent as data.\n\nMoving forward, upgrades other than just `polling -> x` are being considered.\n\n## Timeouts\n\nThe client must use the `pingTimeout` sent as part of the handshake (with\nthe `open` packet) to determine whether the server is unresponsive.\n\nIf no packet type is received withing `pingTimeout`, the client considers\nthe socket disconnected.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/LearnBoost/engine.io-protocol/issues"
  },
  "_id": "engine.io-parser@1.0.0",
  "dist": {
    "shasum": "34a074284bc104d2bfd1291257dff514ada7ed78"
  },
  "_from": "engine.io-parser@1.0.0",
  "_resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-1.0.0.tgz",
  "scripts": {}
}
